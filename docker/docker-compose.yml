# ============================================================================
# Knowledge Graph System - Docker Compose Configuration
# ============================================================================
# PostgreSQL with Apache AGE graph extension for unified data storage
# ============================================================================
#
# Secrets Management (Production):
# For production deployments, use Docker secrets instead of .env files:
#   1. Uncomment the 'secrets:' sections below
#   2. Create secret files: echo "your-key" | docker secret create oauth_signing_key -
#   3. Mount secrets in API container (when API service added)
#
# Development:
# Use .env file (generated by operator/lib/init-secrets.sh)
# ============================================================================

# Uncomment for production deployments using Docker secrets
# secrets:
#   oauth_signing_key:
#     file: ./secrets/oauth_signing_key.txt
#   encryption_key:
#     file: ./secrets/encryption_key.txt
#   postgres_password:
#     file: ./secrets/postgres_password.txt

services:
  postgres:
    # Apache AGE + graph_accel acceleration extension (ADR-201)
    build:
      context: ..
      dockerfile: docker/Dockerfile.postgres
      args:
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
        BUILD_DATE: ${BUILD_DATE:-unknown}
    image: kg-postgres:latest
    container_name: knowledge-graph-postgres
    ports:
      - "5432:5432"  # PostgreSQL connection port
    environment:
      # Database credentials from .env file
      POSTGRES_DB: ${POSTGRES_DB:-knowledge_graph}
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

      # Performance tuning: Use operator/setup/configure-db-profile.sh to apply resource profiles
      # Profiles: small (8GB), medium (16GB), large (32GB+)

    volumes:
      # Data persistence (includes postgresql.auto.conf with ALTER SYSTEM settings)
      - postgres_data:/var/lib/postgresql/data

      # Initialization script (run on first startup only)
      # Note: AGE image provides 00-create-extension-age.sql (runs first)
      # Consolidated baseline schema (v2.0.0) - runs after AGE extension
      - ../schema/00_baseline.sql:/docker-entrypoint-initdb.d/10-baseline.sql
      # graph_accel extension init (conditional - skips if .so not present)
      - ../schema/11_graph_accel.sql:/docker-entrypoint-initdb.d/11-graph-accel.sql

      # Optional: Import directory for bulk data loads
      - postgres_import:/import

    healthcheck:
      # Check if PostgreSQL is ready and AGE extension is loaded
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-admin} -d ${POSTGRES_DB:-knowledge_graph} || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

    networks:
      - kg-network

    restart: unless-stopped

  garage:
    # Garage S3-compatible object storage for image assets
    # Deuxfleurs cooperative governance - no Enterprise edition trap
    image: dxflrs/garage:v1.0.0
    container_name: knowledge-graph-garage
    ports:
      - "3900:3900"  # Garage S3 API
      - "3903:3903"  # Garage Admin API
    environment:
      # Garage RPC secret (from .env, generated by initialize-platform.sh)
      GARAGE_RPC_SECRET: ${GARAGE_RPC_SECRET}

    command: ["/garage", "-c", "/etc/garage.toml", "server"]

    volumes:
      # Data persistence for stored images
      - garage_data:/data
      - garage_meta:/meta
      # Configuration file
      - ../config/garage.toml:/etc/garage.toml:ro

    healthcheck:
      test: ["CMD", "/garage", "status"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

    networks:
      - kg-network

    restart: unless-stopped

  api:
    # FastAPI server (reads config from database)
    build:
      context: ..
      dockerfile: api/Dockerfile
      args:
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
        BUILD_DATE: ${BUILD_DATE:-unknown}
    image: kg-api:latest
    container_name: kg-api-dev
    ports:
      - "8000:8000"  # API endpoint
    environment:
      # Infrastructure secrets (from .env)
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      OAUTH_SIGNING_KEY: ${OAUTH_SIGNING_KEY}
      INTERNAL_KEY_SERVICE_SECRET: ${INTERNAL_KEY_SERVICE_SECRET}

      # Database connection
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB:-knowledge_graph}
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

      # Garage S3 connection
      GARAGE_S3_ENDPOINT: ${GARAGE_S3_ENDPOINT:-http://garage:3900}

      # HuggingFace: Force offline mode (never check network for models)
      # Temporarily disabled to allow initial model download to persistent cache
      # HF_HUB_OFFLINE: "1"
      # TRANSFORMERS_OFFLINE: "1"

      # Application config comes from database (not env)
      # Configured via: kg-operator config ai-provider, embedding, api-key

    volumes:
      # Hot reload: Mount source code for development
      - ../api:/app/api
      # Persistent HuggingFace model cache (prevents re-downloading on restart)
      # Note: API runs as 'api' user, so cache is in /home/api/.cache
      - hf_cache:/home/api/.cache

    depends_on:
      postgres:
        condition: service_healthy
      garage:
        condition: service_healthy

    # GPU support configuration moved to platform-specific override files:
    # - docker-compose.gpu-nvidia.yml: NVIDIA GPU (Linux/Windows with nvidia-docker)
    # - docker-compose.override.mac.yml: Mac (uses MPS, no deploy block needed)
    # - No override: CPU-only mode (works everywhere)
    #
    # The API code auto-detects the best device at runtime:
    # - MPS (Metal Performance Shaders) on Apple Silicon
    # - CUDA on NVIDIA GPUs
    # - CPU fallback when no GPU available

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 600s  # 10 min grace period for initial model downloads (~500MB-1GB)

    # Use public DNS servers to prevent DNS failures when switching WiFi networks
    dns:
      - 8.8.8.8      # Google DNS
      - 1.1.1.1      # Cloudflare DNS

    networks:
      - kg-network

    restart: unless-stopped

  web:
    # React visualization app (runtime config via env vars)
    build:
      context: ../web
      dockerfile: Dockerfile
      args:
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
        BUILD_DATE: ${BUILD_DATE:-unknown}
    image: kg-web:latest
    container_name: kg-web-dev
    ports:
      - "3000:80"  # Web UI
    environment:
      # Runtime config (no rebuild required)
      VITE_API_URL: ${VITE_API_URL:-http://localhost:8000}
      VITE_OAUTH_CLIENT_ID: ${VITE_OAUTH_CLIENT_ID:-kg-cli}
      VITE_OAUTH_REDIRECT_URI: ${VITE_OAUTH_REDIRECT_URI:-http://localhost:3000/callback}
      VITE_APP_NAME: ${VITE_APP_NAME:-Knowledge Graph}

    depends_on:
      api:
        condition: service_healthy

    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s

    networks:
      - kg-network

    restart: unless-stopped

  operator:
    # Platform lifecycle operator (manages other containers via Docker socket)
    build:
      context: ..
      dockerfile: operator/Dockerfile
      args:
        GIT_COMMIT: ${GIT_COMMIT:-unknown}
        BUILD_DATE: ${BUILD_DATE:-unknown}
    image: kg-operator:latest
    container_name: kg-operator
    environment:
      # Database connection (connects to postgres container)
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB:-knowledge_graph}
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

      # Infrastructure secrets (for configure.py operations)
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      OAUTH_SIGNING_KEY: ${OAUTH_SIGNING_KEY}
      INTERNAL_KEY_SERVICE_SECRET: ${INTERNAL_KEY_SERVICE_SECRET}

    volumes:
      # Docker socket access (manage other containers)
      - /var/run/docker.sock:/var/run/docker.sock

      # Mount project workspace for development
      - ..:/workspace

    depends_on:
      postgres:
        condition: service_healthy
      garage:
        condition: service_healthy

    # CMD defined in Dockerfile (operator-start.sh with startup message)

    networks:
      - kg-network

    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  postgres_import:
    driver: local
  garage_data:
    driver: local
  garage_meta:
    driver: local
  hf_cache:
    driver: local

networks:
  kg-network:
    name: knowledge-graph-network
    driver: bridge
