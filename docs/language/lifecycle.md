# Graph Program Lifecycle

How graph programs move from creation to execution across all clients.

**Reference:** [ADR-500 — Graph Program DSL and AST Architecture](../architecture/query-search/ADR-500-graph-program-dsl-and-ast-architecture.md)

---

## Overview

A graph program is a JSON AST (`GraphProgram`) that describes a sequence of
operations against the knowledge graph. Every program follows the same
lifecycle regardless of which client creates or runs it:

```
Author  ──>  Validate (notarize)  ──>  Store  ──>  Retrieve  ──>  Execute
```

The API is the single authority for validation and execution. Clients are
producers of ASTs and consumers of results.

Programs operate across two graphs: **H** (the persistent, read-only
knowledge graph) and **W** (the ephemeral working subgraph built during
execution). All operators read from H and/or W, and write to W.


## 1. Authoring

Programs can originate from any client. All paths produce the same
`GraphProgram` JSON shape.

### 1.1 Web UI

The web app provides three authoring surfaces, all converging on the same IR:

**Smart Search** records exploration steps (concept selection, neighborhood
expansion, path finding, node removal) into the graph store's
`explorationSession`. Each action becomes an `ExplorationStep` with an `op`
(`+` or `-`) and a `cypher` string generated by `stepToCypher()` in
`web/src/utils/cypherGenerator.ts`. The session can be serialized to a
`GraphProgram` by wrapping each step as a `CypherOp` statement.

**Block Builder** compiles a visual block graph into Cypher via
`compileBlocksToIR()` in `web/src/lib/blockCompiler.ts`. Today it emits a
single Cypher string; under ADR-500 it will emit an array of `Statement`
objects with `BlockAnnotation` metadata to enable round-trip decompilation
back to blocks.

**Cypher Editor** lets users write multi-statement scripts with `+`/`-`
operator prefixes. The parser in `parseCypherStatements()`
(`web/src/utils/cypherGenerator.ts`) extracts `{ op, cypher }[]` pairs.
Converting these to `GraphProgram` statements is mechanical: each pair becomes
a `Statement` with `op` and `operation: { type: 'cypher', query }`.

All three surfaces currently feed into the same client-side execution loop
(`handleExecuteCypher` in `SearchBar.tsx`, `replayQuery` in
`useQueryReplay.ts`). Under ADR-500 this loop is replaced by a single
`POST /programs/execute` call.

### 1.2 CLI

The CLI constructs `GraphProgram` JSON directly and submits it to the API. A
program can be built from:

- A JSON file on disk (e.g., `kg program run program.json`)
- Command-line flags that assemble statements programmatically
- Piped input from other tools

The CLI already has `kg query-def` commands for CRUD on query definitions
(`cli/src/cli/query-def.ts`). Program authoring extends this with a
`--type program` option and a `kg program run` subcommand.

### 1.3 MCP Server

The MCP server exposes graph operations as tools. An agent (or any MCP client)
can build a `GraphProgram` incrementally during an exploration session:

1. Use `search` to find concepts, producing statement candidates.
2. Use `concept` with `action: "related"` or `action: "connect"` to expand.
3. Accumulate statements into a `GraphProgram` JSON object.
4. Submit the assembled program to `POST /programs/execute`.

The MCP server can also load and execute stored programs by ID, allowing
agents to reuse programs authored by humans or other agents.

### 1.4 Agents

AI agents author programs by assembling `GraphProgram` JSON through the MCP
tools or direct API calls. The typical agent workflow:

1. Build a linear program from search results and neighborhood expansions.
2. Optionally add conditionals (e.g., "if the initial search found results,
   expand; otherwise try a broader vector search").
3. Bind parameters at execution time.
4. Submit via `POST /programs/execute` and receive the final W.

Agents execute headless — no browser required.

### 1.5 The GraphProgram Shape

Regardless of origin, every program has this structure:

```typescript
{
  version: 1,
  metadata?: ProgramMetadata,            // { name?, description?, author? }
  params?: ParamDeclaration[],           // [{ name, type, default? }]
  statements: Statement[]               // the program body
}

// where each Statement is:
{
  op: Operator,                          // '+' | '-' | '&' | '?' | '!'
  operation: CypherOp | ApiOp | ConditionalOp,
  label?: string,
  block?: BlockAnnotation
}
```

See the [language specification](./specification.md) for the full type
definitions and operator semantics.


## 2. Validation (Notarization)

The API is the sole validation authority. A program is **notarized** when the
API confirms it is structurally sound, safe to execute, and bounded.

### 2.1 Validation Endpoint

```
POST /programs/validate
Content-Type: application/json

{ "version": 1, "statements": [...], "params": [...] }
```

Returns `200` with `{ "valid": true }` or `400` with structured errors:

```json
{
  "valid": false,
  "errors": [
    { "statement": 3, "field": "query", "message": "MATCH without LIMIT on unbounded pattern" }
  ]
}
```

This is a dry-run — the program is not stored.

### 2.2 Validate-and-Store

```
POST /programs
```

Validates the program and, if valid, stores it as a query definition in one
atomic operation. Returns the created definition ID. If validation fails, no
storage occurs and the response is the same `400` error format.

### 2.3 What Validation Checks

The table below summarizes validation categories. For the authoritative rule
catalog with individual rule IDs, see [validation.md](./validation.md).

| Check | What it verifies |
|-------|-----------------|
| **Structural** | Required fields present, `Operator` is one of `+`/`-`/`&`/`?`/`!`, operation type is `cypher`, `api`, or `conditional` |
| **Boundedness** | Total operation count is statically computable and within limits (default: 100). Each conditional branch contributes its longer path. |
| **Cypher safety** | `Statement` objects pass through the query facade safety checks (ADR-048) — no writes, no unbounded MATCH without LIMIT |
| **Parameter resolution** | All `$param` references resolve to declared parameters or provided values |
| **API endpoint allowlist** | `ApiOp` endpoints must be in the permitted set |
| **Nesting depth** | `ConditionalOp` nesting does not exceed maximum (default: 3) |

### 2.4 Client-Side Pre-Validation

Clients may perform local pre-validation for fast feedback (syntax
highlighting, error squiggles in the editor), but this is advisory only. The
API validation is authoritative. A program that passes client-side checks can
still be rejected by the API if, for example, the Cypher safety rules have
changed server-side.


## 3. Storage

### 3.1 Where Programs Live

Programs are stored in the `kg_api.query_definitions` table alongside other
definition types:

```sql
CREATE TABLE kg_api.query_definitions (
    id            SERIAL PRIMARY KEY,
    name          VARCHAR(200) NOT NULL,
    definition_type VARCHAR(50) NOT NULL,  -- 'program'
    definition    JSONB NOT NULL,           -- the GraphProgram AST
    metadata      JSONB,
    owner_id      INTEGER REFERENCES kg_api.users(id),
    created_at    TIMESTAMP DEFAULT NOW(),
    updated_at    TIMESTAMP DEFAULT NOW()
);
```

The `definition_type` for programs is `'program'`. The `definition` JSONB
column contains the complete `GraphProgram` AST — version, metadata,
parameters, and statements.

### 3.2 Ownership

Each definition has an `owner_id` linking to the user who created it. Access
control:

- Users see their own definitions and system-owned definitions (`owner_id IS NULL`).
- Admins (`admin`, `platform_admin` roles) can see and modify all definitions.
- The web UI's navigator panel displays programs alongside other saved query
  types (explorations, polarity analyses, etc.).

### 3.3 CRUD Operations

All clients use the same REST API for storage management:

| Operation | Endpoint | Notes |
|-----------|----------|-------|
| Create | `POST /query-definitions` | Accepts `{ name, definition_type: 'program', definition: { ... } }` |
| List | `GET /query-definitions?definition_type=program` | Paginated, filtered by owner |
| Get | `GET /query-definitions/{id}` | Returns full definition including AST |
| Update | `PUT /query-definitions/{id}` | Partial update of name, definition, or metadata |
| Delete | `DELETE /query-definitions/{id}` | Ownership check enforced |

The web client wraps these through `apiClient.createQueryDefinition()`,
`apiClient.listQueryDefinitions()`, etc. in `web/src/api/client.ts`. The CLI
provides `kg query-def list`, `kg query-def show <id>`,
`kg query-def create`, and `kg query-def delete`.

### 3.4 Programs vs. Other Definition Types

The `query_definitions` table stores multiple definition types. Here is how
they relate:

| Type | definition_type | definition shape |
|------|----------------|-----------------|
| Exploration | `exploration` | `{ statements: [{ op: '+'\|'-', cypher: string }] }` |
| Block diagram | `block_diagram` | `{ nodes, edges }` (ReactFlow layout) |
| Search | `search` | `{ searchParams: {...} }` |
| Polarity | `polarity` | `{ positive_pole_id, negative_pole_id, ... }` |
| Connection | `connection` | `{ from_id, to_id, max_hops }` |
| **Program** | `program` | `{ version: 1, statements: [{ op, operation: {...} }] }` |

Programs subsume explorations — an exploration is a program with only
`CypherOp` statements and only `+` (union) / `-` (difference) operators.
See Section 7 (Migration) for the upgrade path.


## 4. Retrieval

### 4.1 By ID

```
GET /query-definitions/{id}
```

Returns the full definition including the `GraphProgram` AST in the
`definition` field. This is how clients load a specific saved program.

### 4.2 By Type (Listing)

```
GET /query-definitions?definition_type=program&limit=50&offset=0
```

Returns a paginated list of program definitions owned by the current user (or
all definitions for admins). The response includes `total` for pagination.

### 4.3 In the Web UI

The navigator panel (`NavigatorView`) lists saved queries grouped by type.
Programs appear alongside explorations, polarity analyses, and other saved
queries. Clicking a program loads its AST and either:

- Populates the Cypher editor with the text serialization for review/editing.
- Executes the program directly via `POST /programs/execute`.

Currently, `useQueryReplay.ts` handles replay for `exploration` type
definitions by looping through `{ op, cypher }[]` statements, calling
`apiClient.executeCypherQuery()` per statement, and applying
`mergeRawGraphData()` or `subtractRawGraphData()` client-side. Under ADR-500,
this entire loop is replaced by a single `POST /programs/execute` call.


## 5. Execution

### 5.1 Server-Side Execution (Target Architecture)

The executor lives in the API worker. Programs are submitted as JSON ASTs and
executed entirely server-side:

```
POST /programs/execute
Content-Type: application/json

{
  "program": { "version": 1, "statements": [...] },
  "params": { "concept_name": "organizational" }
}
```

Or by reference to a stored program:

```
POST /programs/{id}/execute
Content-Type: application/json

{ "params": { "concept_name": "organizational" } }
```

**Execution flow:**

1. Validate the AST (same checks as `/programs/validate`).
2. Resolve parameters (`$name` substituted with provided values or defaults).
3. Initialize an empty W (the ephemeral working subgraph).
4. For each statement in order:
   a. If `ConditionalOp`: evaluate condition against current W state, select
      `then` or `else` branch.
   b. If `CypherOp`: execute against H (the persistent, read-only knowledge
      graph) via the query facade (ADR-048).
   c. If `ApiOp`: call the internal service function directly (vector search,
      source search, epistemic status — no HTTP round-trip).
   d. Map results to `RawNode[]` and `RawLink[]` format.
   e. Apply the `Operator` to W:
      - `+` (union): merge results into W, deduplicate by `concept_id`.
      - `-` (difference): remove matching nodes and their dangling edges from W.
      - `&` (intersect): keep only W nodes that appear in results.
      - `?` (optional): same as `+`, but empty results are not an error.
      - `!` (assert): same as `+`, but empty results abort the program.
5. Return the final W and a step log.

**Response:**

```typescript
{
  result: WorkingGraph,       // the final W (RawNode[] + RawLink[])
  log: [
    {
      statement: 0,
      op: '+',
      operation_type: 'cypher',
      nodes_affected: 12,
      links_affected: 8,
      w_size: { nodes: 12, links: 8 },
      duration_ms: 45
    },
    // ... one entry per executed statement
  ],
  aborted?: { statement: 3, reason: "Assert failed: empty result" }
}
```

### 5.2 Client-Side Execution (Current / Transition)

During the transition period, clients can continue using the existing
client-side execution loop for simple programs:

1. Load the program's statements.
2. For each statement, call `POST /query/cypher` with the Cypher string.
3. Map the result with `mapCypherResultToRawGraph()`.
4. Apply `+` (union) via `mergeRawGraphData()` or `-` (difference) via `subtractRawGraphData()`.

This is the current behavior in `useQueryReplay.ts` and
`SearchBar.handleExecuteCypher()`. It works for programs that only use
`CypherOp` with `+` (union) and `-` (difference) operators. Programs that
use `&` (intersect), `?` (optional), `!` (assert), `ApiOp`, or
`ConditionalOp` require server-side execution.

The client-side path will be deprecated once the server-side executor is
stable.

### 5.3 Why Server-Side

- **One executor, many clients.** Set algebra is implemented once in the API,
  not reimplemented per client.
- **Smart blocks are internal calls.** `ApiOp` operations (vector search,
  source search) are internal function calls, not HTTP round-trips. A
  10-statement program with 4 smart blocks is 1 HTTP request, not 11.
- **Agents execute headless.** No browser required.
- **W lives server-side during execution.** Only the final W crosses the
  wire.
- **Central auditing.** Execution can be logged, rate-limited, and
  resource-controlled in one place.


## 6. Client Matrix

How each client participates in each lifecycle phase:

| Client | Authors | Validates | Stores | Retrieves | Executes |
|--------|---------|-----------|--------|-----------|----------|
| **Web UI** | Yes (3 surfaces) | Via API | Via API | Via API | Server-side (target), client-side (transition) |
| **CLI** | Yes (JSON/flags) | Via API | Via API | Via API | Server-side or client-side |
| **MCP** | Yes (tool calls) | Via API | Via API | Via API | Server-side or client-side |
| **FUSE** | No | -- | -- | Via API | Triggers execution by program ID |
| **Agents** | Yes (MCP/API) | Via API | Via API | Via API | Server-side |

**Notes:**

- *Web UI* supports all three authoring modes (smart search, blocks, Cypher
  editor). It is the only client that can author via visual blocks.
- *CLI* authors programs as JSON, either inline or from files. It can also
  pipe the text DSL through a future parser.
- *MCP* agents build programs incrementally during exploration sessions. They
  can also load and re-execute stored programs.
- *FUSE* is a read-only client. It can trigger execution of stored programs
  (by mounting a program ID as a virtual file), but it does not author or
  modify programs.
- *Agents* are MCP clients that author and execute programs autonomously. They
  can also borrow programs from users or other agents via the query
  definitions store.


## 7. Migration Path

### 7.1 Exploration to Program

Existing `exploration` definitions have this shape:

```json
{
  "definition_type": "exploration",
  "definition": {
    "statements": [
      { "op": "+", "cypher": "MATCH (c:Concept)-[r]-(n) WHERE c.label = 'X' RETURN c, r, n" },
      { "op": "-", "cypher": "MATCH (c:Concept) WHERE c.label = 'Noise' RETURN c" }
    ]
  }
}
```

Converting to a `program` definition is mechanical:

```json
{
  "definition_type": "program",
  "definition": {
    "version": 1,
    "metadata": { "name": "My Exploration" },
    "statements": [
      {
        "op": "+",
        "operation": {
          "type": "cypher",
          "query": "MATCH (c:Concept)-[r]-(n) WHERE c.label = 'X' RETURN c, r, n"
        }
      },
      {
        "op": "-",
        "operation": {
          "type": "cypher",
          "query": "MATCH (c:Concept) WHERE c.label = 'Noise' RETURN c"
        }
      }
    ]
  }
}
```

The transformation:
1. Add `version: 1` to the definition.
2. For each statement, wrap `{ cypher }` as `{ operation: { type: 'cypher', query: cypher } }`.
3. Change `definition_type` from `'exploration'` to `'program'`.

This can be done as a batch migration or on-demand when an exploration is
loaded. Both the old and new formats can coexist during transition —
`useQueryReplay.ts` can detect the format and dispatch accordingly.

### 7.2 Block Diagram to Program

Block diagram definitions store ReactFlow layout (`{ nodes, edges }`) and
are not directly executable — they require the block compiler to produce
Cypher. Under ADR-500, the block compiler gains a second output path that
emits `Statement[]` with `BlockAnnotation` metadata. Once compiled, the
result is a standard `GraphProgram` that can be stored as a `program`
definition.

### 7.3 Definition Type Registry

The `DEFINITION_TYPES` list in `api/app/models/query_definition.py` will be
extended to include `'program'`:

```python
DEFINITION_TYPES = [
    'block_diagram',
    'cypher',
    'search',
    'polarity',
    'connection',
    'exploration',
    'program',       # ADR-500
]
```

A database migration adds the new value to the `definition_type` check
constraint.

### 7.4 Replay Hook Migration

`useQueryReplay.ts` currently handles three definition types: `exploration`,
`polarity`, and legacy `searchParams`. The migration adds a `program` handler:

```typescript
if (query.definition_type === 'program') {
  const result = await apiClient.executeProgram(query.definition);
  // result.result is a WorkingGraph (RawNode[] + RawLink[])
  setRawGraphData(result.result);
  return;
}
```

The exploration replay path remains as a fallback until all explorations are
migrated.


## 8. Worked Example

End-to-end lifecycle for a program that finds organizational patterns:

### 8.1 Authoring (Web UI, Cypher Editor)

A user writes this in the Cypher editor:

```
+ MATCH (c:Concept)-[r]-(n:Concept)
  WHERE c.label CONTAINS 'organizational'
  RETURN c, r, n
  LIMIT 50;

- MATCH (c:Concept) WHERE c.grounding_strength < 0.2 RETURN c;
```

The editor parses this into:

```json
[
  { "op": "+", "cypher": "MATCH (c:Concept)-[r]-(n:Concept) WHERE c.label CONTAINS 'organizational' RETURN c, r, n LIMIT 50" },
  { "op": "-", "cypher": "MATCH (c:Concept) WHERE c.grounding_strength < 0.2 RETURN c" }
]
```

### 8.2 Constructing the GraphProgram

The client wraps the parsed statements into a `GraphProgram`:

```json
{
  "version": 1,
  "metadata": { "name": "Organizational Patterns", "author": "human" },
  "statements": [
    {
      "op": "+",
      "operation": { "type": "cypher", "query": "MATCH (c:Concept)-[r]-(n:Concept) WHERE c.label CONTAINS 'organizational' RETURN c, r, n LIMIT 50" },
      "label": "Find organizational concepts"
    },
    {
      "op": "-",
      "operation": { "type": "cypher", "query": "MATCH (c:Concept) WHERE c.grounding_strength < 0.2 RETURN c" },
      "label": "Remove weakly grounded"
    }
  ]
}
```

### 8.3 Validation

```
POST /programs/validate
--> { "valid": true }
```

### 8.4 Storage

```
POST /query-definitions
{
  "name": "Organizational Patterns",
  "definition_type": "program",
  "definition": { ... the GraphProgram above ... }
}
--> { "id": 42, "name": "Organizational Patterns", ... }
```

### 8.5 Retrieval (CLI)

```bash
kg query-def show 42
```

Displays the stored program definition.

### 8.6 Execution (Agent via MCP)

An agent loads and executes the stored program with a parameter override:

```
POST /programs/42/execute
{ "params": { "concept_name": "governance" } }
```

The API returns the final W (`WorkingGraph` containing `RawNode[]` and
`RawLink[]`) and a step log showing how many nodes and links each statement
contributed.


## 9. Implementation Phases

### Phase 1: AST Foundation and API Executor

- Define `GraphProgram` types in a shared schema.
- Implement `POST /programs/validate` (structural + safety checks).
- Implement `POST /programs/execute` (server-side executor, `CypherOp` and
  `ApiOp`, all five operators, step log).
- Add `'program'` to `DEFINITION_TYPES`.
- Web client calls execute endpoint instead of local statement loop.

### Phase 2: Branching and Parameters

- `ConditionalOp` in executor and validator.
- Parameter declarations and `$param` substitution.
- Nesting depth and operation count enforcement.
- CLI and MCP can submit programs with bound parameters.

### Phase 3: Round-Trip and Authoring

- Block annotation preservation through serialize/deserialize cycle.
- Text DSL parser handles `@block`, `@api`, `@param`, `IF` directives.
- AST-to-blocks decompiler reconstructs visual block layout.
- Per-user execution history stored alongside program definitions.
